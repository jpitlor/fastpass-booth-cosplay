     1	import bluetooth
     2	import queue
     3	import threading
     4	import time
     5	
     6	# the amount of time without sending any messages before disconnecting
     7	AUTO_DISCONNECT_TIMEOUT = 30
     8	
     9	
    10	class ClientThread(threading.Thread):
    11	    def __init__(self, receive_size=4096):
    12	        super().__init__()
    13	
    14	        self.receive_size = receive_size
    15	
    16	        self.sock = None
    17	        self.alive = threading.Event()
    18	
    19	        self.outbound_q = queue.Queue()
    20	        self.inbound_q = queue.Queue()
    21	
    22	        self.disconnect_timer = threading.Timer(
    23	            AUTO_DISCONNECT_TIMEOUT,
    24	            self.disconnect
    25	        )
    26	
    27	    def connect(self, mac, port):
    28	        # create socket and connect
    29	        sock = bluetooth.BluetoothSocket(bluetooth.RFCOMM)
    30	        sock.connect((mac, port))
    31	
    32	        self.sock = sock
    33	        self.alive.set()
    34	        self.start()
    35	
    36	    def run(self):
    37	        while self.alive.is_set():
    38	            # check that the socket is still active
    39	            try:
    40	                self.sock.getpeername()
    41	            except bluetooth.btcommon.BluetoothError:
    42	                self.disconnect()
    43	
    44	            # block for sending messages
    45	            self.sock.setblocking(True)
    46	
    47	            # send any out bound messages
    48	            try:
    49	                # get the next out queue item
    50	                message = self.outbound_q.get(True, 0.1)
    51	
    52	                self.sock.send(message)
    53	
    54	                time.sleep(0.02)
    55	
    56	                # reset the timer
    57	                self.disconnect_timer.cancel()
    58	                self.disconnect_timer = threading.Timer(
    59	                    AUTO_DISCONNECT_TIMEOUT,
    60	                    self.disconnect
    61	                )
    62	            except queue.Empty:
    63	                pass
    64	
    65	            # skip blocking for receiving messages, an exception will be raised if there's no data
    66	            self.sock.setblocking(False)
    67	
    68	            # receive incoming messages
    69	            try:
    70	                self.inbound_q.put(self.sock.recv(self.receive_size))
    71	            except bluetooth.btcommon.BluetoothError:
    72	                pass
    73	
    74	    def disconnect(self, timeout=None):
    75	        if self.sock:
    76	            self.sock.close()
    77	
    78	        self.disconnect_timer.cancel()
    79	
    80	        # unset the alive event so run() will not continue
    81	        self.alive.clear()
    82	
    83	        try:
    84	            # block the calling thread until this thread completes
    85	            threading.Thread.join(self, timeout)
    86	        except RuntimeError:
    87	            pass
